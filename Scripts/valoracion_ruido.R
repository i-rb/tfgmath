# -*- coding: utf-8 -*-
"""Valoracion_ruido.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10KAyB3aUQKAcImzdAAFIEIC6TWoLzvPN

# Test de valoracion del ruido
"""

devtools::install_github("cran/TSA")
install.packages("DataCombine")
install.packages("forecast")

library(DataCombine)
library(forecast)
library(TSA)

# data
ibmdata = read.csv("IBM.csv",sep=",") # read csv 
ibmdata$Date <- as.Date(ibmdata$Date,format="%Y-%m-%d") # date formatting
ln_diff=c(NA,diff(log(ibmdata$Close)))
ibmdata$d_ln_close=ln_diff #creamos la variable d_ln_y (1st row, NA)
y=ibmdata$d_ln_close[2:nrow(ibmdata)]

# no linealidad (se comprobara hasta el grado de expansion de Volterra k=4, d=4)
ibmdata <- slide(ibmdata, "d_ln_close", NewVar = "d_ln_close_1", slideBy = -1)  # create lag1 variable
ibmdata <- slide(ibmdata, "d_ln_close", NewVar = "d_ln_close_2", slideBy = -2)  # create lag1 variable
ibmdata <- slide(ibmdata, "d_ln_close", NewVar = "d_ln_close_3", slideBy = -3)  # create lag1 variable
ibmdata <- slide(ibmdata, "d_ln_close", NewVar = "d_ln_close_4", slideBy = -4)  # create lag1 variable

ibmdata=ibmdata[6:nrow(ibmdata),]

head(ibmdata)

"""**Modelos Lineales: (d=1)**"""

# d=1 k=1
mod <-lm(d_ln_close ~ d_ln_close_1, data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=1 k=2
mod <-lm(d_ln_close ~ d_ln_close_1 + d_ln_close_2, data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=1 k=3
mod <-lm(d_ln_close ~ d_ln_close_1 + d_ln_close_2 + d_ln_close_3, data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=1 k=4
mod <-lm(d_ln_close ~ d_ln_close_1 + d_ln_close_2 + d_ln_close_4, data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

"""**Modelos no-lineales (d=2,3,4)**"""

# d=2 k=1
mod <-lm(d_ln_close ~ d_ln_close_1 
                    + d_ln_close_1^2, 
                    data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=2 k=2
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2 + 
                      d_ln_close_1^2 + d_ln_close_2^2, 
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=2 k=3
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2   + d_ln_close_3    +
                      d_ln_close_1^2 + d_ln_close_2^2 + d_ln_close_3^2, 
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=2 k=4
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2   + d_ln_close_3   + d_ln_close_4   + 
                      d_ln_close_1^2 + d_ln_close_2^2 + d_ln_close_3^2 + d_ln_close_4^2,
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=3 k=1
mod <-lm(d_ln_close ~ d_ln_close_1 
                    + d_ln_close_1^2
                    + d_ln_close_1^3, 
                    data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=3 k=2
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2 + 
                      d_ln_close_1^2 + d_ln_close_2^2 +
                      d_ln_close_1^3 + d_ln_close_2^3, 
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=3 k=3
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2 +   d_ln_close_3   +
                      d_ln_close_1^2 + d_ln_close_2^2 + d_ln_close_3^2 +
                      d_ln_close_1^3 + d_ln_close_2^3 + d_ln_close_3^3, 
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=3 k=4
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2 +   d_ln_close_3   + d_ln_close_4   +
                      d_ln_close_1^2 + d_ln_close_2^2 + d_ln_close_3^2 + d_ln_close_4^2 + 
                      d_ln_close_1^3 + d_ln_close_2^3 + d_ln_close_3^3 + d_ln_close_4^3,
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=4 k=1
mod <-lm(d_ln_close ~ d_ln_close_1 
                    + d_ln_close_1^2
                    + d_ln_close_1^3
                    + d_ln_close_1^4, 
                    data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=4 k=2
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2 + 
                      d_ln_close_1^2 + d_ln_close_2^2 +
                      d_ln_close_1^3 + d_ln_close_2^3 +
                      d_ln_close_1^4 + d_ln_close_2^4, 
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=4 k=3
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2 +   d_ln_close_3   +
                      d_ln_close_1^2 + d_ln_close_2^2 + d_ln_close_3^2 +
                      d_ln_close_1^3 + d_ln_close_2^3 + d_ln_close_3^3 +
                      d_ln_close_1^4 + d_ln_close_2^4 + d_ln_close_3^4, 
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

# d=4 k=4
mod <-lm(d_ln_close ~ d_ln_close_1   + d_ln_close_2 +   d_ln_close_3   + d_ln_close_4   +
                      d_ln_close_1^2 + d_ln_close_2^2 + d_ln_close_3^2 + d_ln_close_4^2 + 
                      d_ln_close_1^3 + d_ln_close_2^3 + d_ln_close_3^3 + d_ln_close_4^3 +
                      d_ln_close_1^4 + d_ln_close_2^4 + d_ln_close_3^4 + d_ln_close_4^4,
                      data=ibmdata)
bic=AIC(mod,k = log(length(nrow(ibmdata))))
bic

"""## Deteccion de Caos
Dado que el óptimo se alcanza para d=2,3,4 frente a d=1 con 4 retardos, hay indicios de que existe cierta componente no-lineal. Por ello, prueba a comprobarse si existe caos a través de la adición de ruido de una normal (0, $\sigma$). Se utiliza el test de Tsay a partir de ahora, debido a su claridad.
"""

sigma=0
print(c("Sigma", "p-value"))
print(c(sigma,Tsay.test(y)$p.value))

cat(" σ ", ":","p-value","\n")
dty=sd(y)
for (i in seq(0.1,2,0.35)){
  ruido=rnorm(length(y),mean=0,sd=i*dty) # en funcion de la dt de la serie
  serieruido=y+i*ruido
  cat(round(i, digits = 1),":",round(Tsay.test(serieruido,1)$p.value,digits=3),"\n")}

# parece ser que alrededor del 0.8, pero no parece muy robusto.

arma = as.numeric(read.csv("arma11.csv",sep=",",header=FALSE)[,1]) # read csv 
garc = as.numeric(read.csv("garc11.csv",sep=",",header=FALSE)[,1]) # read csv 
egar = as.numeric(read.csv("egar21.csv",sep=",",header=FALSE)[,1]) # read csv

##### arma

y=arma

sigma=0
print(c("Sigma", "p-value"))
print(c(sigma,Tsay.test(y,1)$p.value))

cat(" σ ", ":","p-value","\n")
dty=sd(y)
for (i in seq(0.1,2,0.35)){
  ruido=rnorm(length(y),mean=0,sd=i*dty) # en funcion de la dt de la serie
  serieruido=y+i*ruido
  cat(round(i, digits = 1),":",round(Tsay.test(serieruido,1)$p.value,digits=3),"\n")}

##### garch

y=garc

sigma=0
print(c("Sigma", "p-value"))
print(c(sigma,Tsay.test(y,1)$p.value))

cat(" σ ", ":","p-value","\n")
dty=sd(y)
for (i in seq(0.1,2,0.35)){
  ruido=rnorm(length(y),mean=0,sd=i*dty) # en funcion de la dt de la serie
  serieruido=y+i*ruido
  cat(round(i, digits = 1),":",round(Tsay.test(serieruido,1)$p.value,digits=3),"\n")}

##### egar

y=egar

sigma=0
print(c("Sigma", "p-value"))
print(c(sigma,Tsay.test(y,1)$p.value))

cat(" σ ", ":","p-value","\n")
dty=sd(y)
for (i in seq(0.1,2,0.35)){
  ruido=rnorm(length(y),mean=0,sd=i*dty) # en funcion de la dt de la serie
  serieruido=y+i*ruido
  cat(round(i, digits = 1),":",round(Tsay.test(serieruido,1)$p.value,digits=3),"\n")}

